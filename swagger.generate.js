const fs = require('fs');
const path = require('path');
const swaggerAutogen = require('swagger-autogen')();

const outputFile = './swagger_output.json';
// Only scan server.js; it already mounts all routes with correct prefixes.
// Scanning individual route files creates duplicate endpoints.
const endpointsFiles = ['./src/server.js'];

const doc = {
  info: {
    title: 'Netflix API',
    description: 'API docs generated by swagger-autogen'
  },
  host: `localhost:${process.env.PORT || 3000}`,
  schemes: ['http'],
  components: {
    securitySchemes: {
      bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' }
    },
    schemas: {
      User: {
        type: 'object',
        properties: {
          id: { type: 'integer', example: 1 },
          email: { type: 'string', example: 'user@example.com' },
          username: { type: 'string', example: 'VanAn17' },
          full_name: { type: 'string', example: 'Nguyen Van An' }
        }
      },
      AuthResponse: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          data: {
            type: 'object',
            properties: {
              user: { $ref: '#/components/schemas/User' },
              token: { type: 'string' }
            }
          }
        }
      }
    }
  },
  security: [{ bearerAuth: [] }]
};

// Tag mappings based on path patterns
const getTagForPath = (pathKey) => {
  if (pathKey.includes('/auth')) return 'Authentication';
  if (pathKey.includes('/admin')) return 'Admin';
  if (pathKey.includes('/stats')) return 'Statistics';
  if (pathKey.includes('/users')) return 'Users';
  if (pathKey.includes('/movies')) return 'Movies';
  if (pathKey.includes('/orders')) return 'Orders';
  if (pathKey.includes('/watchlist')) return 'WatchList';
  if (pathKey.includes('/promos')) return 'Discounts';
  if (pathKey.includes('/subscriptions')) return 'Subscriptions';
  return 'General';
};

const convertToOAS31 = (spec) => {
  const oas = {};
  oas.openapi = '3.1.0';
  oas.info = spec.info || { title: 'API', version: '1.0.0' };
  oas.servers = [ { url: `http://localhost:${process.env.PORT || 3000}` } ];
  oas.components = spec.components || {};
  if (spec.security) oas.security = spec.security;
  
  // Define tags for grouping endpoints
  oas.tags = [
    { name: 'Authentication', description: 'User authentication and authorization' },
    { name: 'Users', description: 'User profile and management' },
    { name: 'Admin', description: 'Admin operations' },
    { name: 'Statistics', description: 'Analytics and statistics' },
    { name: 'General', description: 'General endpoints' },
    { name: 'Movies', description: 'Movie management and listings' },
    { name: 'WatchList', description: 'mange user favorite movies' },
    { name: 'Discounts', description: 'Discount management and listing' },
    { name: 'Subscriptions', description: 'Subscription plans and management' },
  ];
  
  oas.paths = {};

  for (const [pathKey, methods] of Object.entries(spec.paths || {})) {
    oas.paths[pathKey] = {};
    for (const [method, op] of Object.entries(methods)) {
      const newOp = Object.assign({}, op);
      const params = [];
      let requestBody = null;
      let hasAuthHeader = false;

      // Add tag based on path
      newOp.tags = [getTagForPath(pathKey)];

      if (Array.isArray(op.parameters)) {
        for (const p of op.parameters) {
          if (p.in === 'body') {
          requestBody = requestBody || {
            required: p.required === true,
            content: {
              'application/json': {
                schema: p.schema || { type: 'object' }
              }
            }
          };
        } else {
            // If the parameter is the Authorization header, skip it and mark for security
            if (p.in === 'header' && typeof p.name === 'string' && p.name.toLowerCase() === 'authorization') {
              hasAuthHeader = true;
              continue;
            }

            const param = Object.assign({}, p);
            if (!param.schema) {
              const schema = {};
              if (param.type) schema.type = param.type;
              param.schema = Object.keys(schema).length ? schema : { type: 'string' };
              delete param.type;
            }
            params.push(param);
          }
        }
      }

      if (params.length) newOp.parameters = params;
      else delete newOp.parameters;

      if (requestBody) newOp.requestBody = requestBody;

      // If the operation previously required an Authorization header, use security scheme instead
      if (hasAuthHeader) {
        newOp.security = [{ bearerAuth: [] }];
      }

      newOp.responses = newOp.responses || {
      '200': {
        description: 'OK',
        content: {
          'application/json': {
            schema: { type: 'object' }
          }
        }
      }
    };


      oas.paths[pathKey][method] = newOp;
    }
  }

  return oas;
};

swaggerAutogen(outputFile, endpointsFiles, doc).then(() => {
  try {
    const raw = fs.readFileSync(outputFile, 'utf8');
    const spec = JSON.parse(raw);
    const oas = convertToOAS31(spec);
    fs.writeFileSync(outputFile, JSON.stringify(oas, null, 2), 'utf8');
    console.log(`✅ Swagger generated and converted to OpenAPI 3.1 at ${outputFile}`);
  } catch (err) {
    console.error('❌ Post-process conversion to OAS3.1 failed:', err);
  }
}).catch(err => {
  console.error('❌ Swagger generation failed:', err);
});
